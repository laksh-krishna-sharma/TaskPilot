from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import logging
from agent_runner import run_agent_task
from github_integration import parse_llm_output, create_github_repo
from typing import List, Optional
import os
import json
import requests
import time

# Ensure logs directory exists
os.makedirs('logs', exist_ok=True)

# Configure logging
logging.basicConfig(
    filename='logs/agent.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

app = FastAPI()

class Attachment(BaseModel):
    name: str
    url: str  # Data URI

class DeploymentRequest(BaseModel):
    email: str
    secret: str
    task: str
    round: int
    nonce: str
    brief: str
    checks: List[str]
    evaluation_url: str
    attachments: Optional[List[Attachment]] = []

class EvaluationResponse(BaseModel):
    email: str
    task: str
    round: int
    nonce: str
    repo_url: str
    commit_sha: str
    pages_url: str

def verify_secret(email: str, secret: str) -> bool:
    secrets_str = os.getenv("STUDENT_SECRETS", "{}")
    try:
        secrets = json.loads(secrets_str)
        return secrets.get(email) == secret
    except json.JSONDecodeError:
        logging.error("Invalid STUDENT_SECRETS format")
        return False

@app.post("/task")
def run_task(task: DeploymentRequest):
    logging.info(f"Received deployment request: {task.email} - {task.task} - round {task.round}")
    
    # Verify secret
    if not verify_secret(task.email, task.secret):
        logging.warning(f"Invalid secret for {task.email}")
        raise HTTPException(status_code=403, detail="Invalid secret")
    
    try:
        # Generate app with LLM
        result = run_agent_task(task.brief, task.checks, [att.dict() for att in task.attachments] if task.attachments else None)
        if result.returncode != 0:
            logging.error(f"LLM task failed: {result.stderr}")
            raise HTTPException(status_code=400, detail=result.stderr)
        
        # Parse LLM output
        files = parse_llm_output(result.stdout)
        if not files:
            logging.error("No files generated by LLM")
            raise HTTPException(status_code=400, detail="Failed to generate app files")
        
        # Create GitHub repo
        repo_info = create_github_repo(task.task, files, task.brief, task.checks, [att.dict() for att in task.attachments] if task.attachments else [], task.round)
        
        # Ping evaluation URL
        eval_data = {
            "email": task.email,
            "task": task.task,
            "round": task.round,
            "nonce": task.nonce,
            **repo_info
        }
        
        # Retry logic
        for attempt in range(4):  # 0,1,2,3
            try:
                response = requests.post(task.evaluation_url, json=eval_data, timeout=10)
                if response.status_code == 200:
                    break
                else:
                    logging.warning(f"Evaluation ping attempt {attempt+1} failed: {response.status_code}")
            except Exception as e:
                logging.warning(f"Evaluation ping attempt {attempt+1} error: {e}")
            if attempt < 3:
                time.sleep(2 ** attempt)  # 1, 2, 4 seconds
        
        logging.info(f"Deployment completed: {repo_info['repo_url']}")
        return {"status": "success", "repo_url": repo_info['repo_url'], "pages_url": repo_info['pages_url']}
    except Exception as e:
        logging.error(f"Exception: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
def health():
    return {"status": "ok"}
